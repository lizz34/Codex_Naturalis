/***
	 * controlla che l'obiettivo della carta che gli viene passata sia soddisfatto sul corrente campo da gioco
	 * @param o: la carta obiettivo da controllare
	 * @return il punteggio che va aggiunto al giocatore se l'obiettivo é soddisfatto
	 */
	public int controllaObiettivo(CartaObiettivo o) {
		int punti = 0; //punti che verrano aggiunti al punteggio del giocatore in seguito al controllo sulla carta obiettivo
		if(o.getIndex() >= 0 && o.getIndex() <= 7) { //obiettivi per il controllo delle figure
			
			int contatore [] = new int [7];
			List <Integer> temp = new ArrayList <Integer>();
			this.contaFigure(contatore);  //conta le figure presenti sul campo di gioco
			
			switch(o.getIndex()) {
			case 0: //2 punti x 2 piume
				punti = 2 * (contatore[5] / 2);
				break;
			case 1: //2 punti x 2 boccette
				punti = 2 * (contatore[4] / 2);
				break;
			case 2: //2 punti x 2 pergamene
				punti = 2 * (contatore[6] / 2);
				break;
			case 3: //3 punti x 1 boccetta, 1 piuma, 1 pergamena
				temp.add(contatore[4]); //boccetta
				temp.add(contatore[5]); //piuma
				temp.add(contatore[6]); //pergamena 
				
				//moltiplica il modificatore di punteggio per il valore minore tra tre disegni che necessita
				//(vuol dire che sicuramente gli altri ne hanno di piu' e non bisogna fare ulteriori controlli)
				punti = 3 * Collections.min(temp);
				temp.clear();			
				break;
			case 4: //2 punti x 3 farfalle
				punti = 2 * (contatore[2] / 3);
				break;
			case 5: //2 punti x 3 lupi
				punti = 2 * (contatore[0] / 3);
				break;
			case 6: //2 punti x 3 foglie
				punti = 2 * (contatore[1] / 3);
				break;
			case 7: //2 punti x 3 funghi
				punti = 2 * (contatore[3] / 3);
				break;
			}
		}
		else {
			//obiettivi per il controllo della disposizione delle carte
			switch(o.getIndex()) {
			//casi disposizione a "L" (3 punti se soddisfatto)
			case 8:
				punti = this.obiettivoVerticaleInferiore(Colore.viola, Colore.blu, +1, +1, +2)*3;
				break;
			case 9:
				punti = this.obiettivoVerticaleInferiore(Colore.blu, Colore.rosso, -1, +1, +2)*3;
				break;
			case 10:
				punti = this.obiettivoVerticaleSuperiore(Colore.verde, Colore.viola, -1, +1, +2)*3;
				break;
			case 11:
				punti = this.obiettivoVerticaleSuperiore(Colore.rosso, Colore.verde, +1, +1, +2)*3;
				break;
			//casi disposizione diagonale
			case 12:
				//2 punti x ogni 3 carte viola disposte diagonalmente verso destra (partendo dall'alto)
				punti = this.obiettivoDiagonaleDestra(Colore.viola)*2;
				break;
			case 13:
				//2 punti x ogni 3 carte blu disposte diagonalmente verso sinistra (partendo dall'alto)
				punti = this.obiettivoDiagonaleSinistra(Colore.blu)*2;
				break;
			case 14:
				//2 punti x ogni 3 carte verdi disposte diagonalmente verso destra (partendo dall'alto)
				punti = this.obiettivoDiagonaleDestra(Colore.verde)*2;
				break;
			case 15: 
				//2 punti x ogni 3 carte rosse disposte diagonalmente verso sinistra (partendo dall'alto)
				punti = this.obiettivoDiagonaleSinistra(Colore.rosso)*2;
				break;
			}
		}
		return punti;
	}
	
	/***
	 * Controllo per le carte obiettivo: 3 carte di uno stesso colore poste in diagonale verso destra (partendo dall'alto)
	 * @param colore: il colore che devono avere le 3 carte
	 * @return true se la disposizione è presente, false in caso contrario
	 */
	public int obiettivoDiagonaleDestra(Colore colore) {
		Set<Integer> index = new HashSet<Integer>();
		int tris=0;
		
		for(int i = 0; i < nRigheTabella; i++) { //scorre le righe della tabella
			for(int j = 0; j < nColonneTabella; j++) {
				if(campoPersonale[i][j] != null) {
					if(campoPersonale[i][j].getColore().equals(colore)){
						//trovata una carta che ha lo stesso colore che serve nell'obiettivo, controllo sulle carte in diagonale
						if(campoPersonale[i+1][j+1]!=null && campoPersonale[i+2][j+2]!=null) {
							if(campoPersonale[i+1][j+1].getColore().equals(colore) && campoPersonale[i+2][j+2].getColore().equals(colore)) {
								if(controllaIndici(index, i, j, i+1, j+1, i+2, j+2)) {
									//sono state trovate due carte sulla diagonale verso destra che hanno lo stessso colore
									index.add(i);
									index.add(j);
									index.add(i+1);
									index.add(j+1);
									index.add(i+2);
									index.add(j+2);
									tris++;
								}
							}
						}
					}
				}
			}
		}
		
		return tris;
		/*
		 * copio tutto in una nuova matrice e se trovo le carte le cancello definitivamente
		Carta cg1[][] = new Carta[this.nRigheTabella][this.nColonneTabella];
		
		for(int i = 0; i < nRigheTabella; i++) {
			for(int j = 0; j < nColonneTabella; j++) {
				cg1[i][j] = campoPersonale[i][j].deepCopy();
			}		
		}
		*/
		
		/*
		for(int i = 0; i < nRigheTabella; i++) { //scorre le righe della tabella
			for(int j = 0; j < nColonneTabella; j++) {
				if(campoPersonale[i][j].getColore().equals(colore)){
					//trovata una carta che ha lo stesso colore che serve nell'obiettivo, controllo sulle carte in diagonale
					if(campoPersonale[i+1][j+1].getColore().equals(colore) && campoPersonale[i+2][j+2].getColore().equals(colore)) {
						//sono state trovate due carte sulla diagonale verso destra che hanno lo stessso colore
						return true;
					}
				}
			}		
		}
		return false;
		*/
	}
	
	/***
	 * Controllo per le carte obiettivo: 3 carte di uno stesso colore poste in diagonale verso sinistra (partendo dall'alto)
	 * @param colore: il colore che devono avere le 3 carte
	 * @return true se la disposizione è presente, false in caso contrario
	 */
	public int obiettivoDiagonaleSinistra(Colore colore) {
		Set<Integer> index = new HashSet<Integer>();
		int tris=0;
		
		for(int i = 0; i < nRigheTabella; i++) { //scorre le righe della tabella
			for(int j = 0; j < nColonneTabella; j++) {
				if(campoPersonale[i][j] != null) {
					if(campoPersonale[i][j].getColore().equals(colore)){
						if(campoPersonale[i+1][j-1]!=null && campoPersonale[i+2][j-2]!=null) {
							//trovata una carta che ha lo stesso colore che serve nell'obiettivo, controllo sulle carte in diagonale
							if(campoPersonale[i+1][j-1].getColore().equals(colore) && campoPersonale[i+2][j-2].getColore().equals(colore)) {
								if(controllaIndici(index, i, j, i+1, j-1, i+2, j-2)) {
									//sono state trovate due carte sulla diagonale verso destra che hanno lo stessso colore
									index.add(i);
									index.add(j);
									index.add(i+1);
									index.add(j-1);
									index.add(i+2);
									index.add(j-2);
									tris++;
								}
							}
						}
					}
				}
			}
		}
		
		return tris;
		
		/*
		for(int i = 0; i < nRigheTabella; i++) { //scorre le righe della tabella
			for(int j = 0; j < nColonneTabella; j++) {
				if(campoPersonale[i][j].getColore().equals(colore)){
					//trovata una carta che ha lo stesso colore che serve nell'obiettivo, controllo sulle carte in diagonale
					if(campoPersonale[i+1][j-1].getColore().equals(colore) && campoPersonale[i+2][j-2].getColore().equals(colore)) {
						//sono state trovate due carte sulla diagonale verso destra che hanno lo stessso colore
						return true;
					}
				}
			}		
		}
		return false;
		*/
	}
	
	/***
	 * funzione per controllare la carta obiettivo che ha la disposizione di due carte in verticale una sopra l'altra con 
	 * un dato colore e un'altra carta posta in diagonale rispetto a quella piu' alta con un altro colore.
	 * il calcolo viene fatto partendo dalla carta posta piu' in alto nella disposizione (in questo caso quella con colore diverso)
	 * @param colVerticale: il colore delle carte verticali
	 * @param col1: il colore della carta posta in diagonale
	 * @param modColonna: il modificatore delle colonne rispetto alla carta da cui si parte a contare
	 * @param modRiga1: il modificare di riga della prima carta verticale
	 * @param modRiga2: il modificatore di riga rispetto alla seconda carta verticale
	 * @return true se l'obiettivo é soddisfatto, false in caso contrario
	 */
	public int obiettivoVerticaleInferiore(Colore colVerticale, Colore col1, int modColonna, int modRiga1, int modRiga2) {
		Set<Integer> index = new HashSet<Integer>();
		int tris=0;
		
		for(int i = 0; i < nRigheTabella; i++) {	//scorre righe tabella
			for(int j = 0; j < nColonneTabella; j++) {	//scorre colonna tabella
				if(campoPersonale[i][j] != null) {
					if(campoPersonale[i][j].getColore().equals(col1)) {
						//trovata carta con un colore che corrisponde con il colore della carta non in verticale
						if(campoPersonale[i+modRiga1][j+modColonna]!=null && campoPersonale[i+modRiga2][j+modColonna]!=null) {
							if(campoPersonale[i+modRiga1][j+modColonna].getColore().equals(colVerticale) &&
								campoPersonale[i+modRiga2][j+modColonna].getColore().equals(colVerticale)) {
								if(controllaIndici(index, i, j, i+modRiga1, j+modColonna, i+modRiga2, j+modColonna)) {
									//sono state trovate due carte, poste in verticale secondo la disp richiesta, con il colore richiesto
									index.add(i);
									index.add(j);
									index.add(i+modRiga1);
									index.add(j+modColonna);
									index.add(i+modRiga2);
									index.add(j+modColonna);
									tris++;
								}
							}
						}
					}
				}
			}
		}
		return tris;
	}
	
	/***
	 * funzione per controllare la carta obiettivo che ha la disposizione di due carte in verticale una sopra l'altra con
	 * lo stesso colore e un'altras crta posta in diagonale rispetto alla carta piu' bassa con un altro colore.
	 * il calcolo viene fatto partendo dalla carta piu' in alto (in questo caso la prima delle carte verticali)
	 * @param colVerticale: il colore delle carte verticali
	 * @param col1: il colore della carta posta in diagonale
	 * @param modColonna: il modificatore di colonna rispetto alla carta da cui si parte a contare (per la carta in diagonale)
	 * @param modRiga1: il modificatore di riga della seconda carta verticale
	 * @param modRiga2: il modificatore di riga per la carta in diagonale
	 * @return true se l'obiettivo é soddisfatto, false in caso contrario
	 */
	public int obiettivoVerticaleSuperiore(Colore colVerticale, Colore col1, int modColonna, int modRiga1, int modRiga2) {
		Set<Integer> index = new HashSet<Integer>();
		int tris=0;
		
		for(int i = 0; i < nRigheTabella; i++) {	//scorre righe tabella
			for(int j = 0; j < nColonneTabella; j++) {	//scorre colonna tabella
				if(campoPersonale[i][j]!=null) {
					if(campoPersonale[i][j].getColore().equals(colVerticale)) {
						//trovata carta con colore che corrisponde con quello della carta verticale piu' in alto
						if(campoPersonale[i+modRiga1][j]!=null && campoPersonale[i+modRiga2][j+modColonna]!=null) {
							if(campoPersonale[i+modRiga1][j].getColore().equals(colVerticale) && 
								campoPersonale[i+modRiga2][j+modColonna].getColore().equals(col1)) {
								if(controllaIndici(index, i, j, i+modRiga1, j, i+modRiga2, j+modColonna)) {
									//trovate due carte che soddisfano i requisiti di disposizione e colore
									index.add(i);
									index.add(j);
									index.add(i+modRiga1);
									index.add(j);
									index.add(i+modRiga2);
									index.add(j+modColonna);
									tris++;
								}
							}
						}
					}
				}
			}
		}
		
		return tris;
	}
	